[
	{
		"uri": "https://takinprofit.github.io/FractalDb/schemas.html",
		"title": "Schemas",
		"content": "\nSchemas\nSchemas define how FractalDb stores and indexes your documents. Use the schema\u0026lt;\u0027T\u0026gt; { } computation expression to specify indexed fields, uniqueness constraints, and validation rules.\nWhy Schemas Matter\nSchemas provide:\n\nPerformance - Indexed fields enable fast queries (28x speedup)\nData Integrity - Unique constraints prevent duplicates\nValidation - Enforce business rules before storing data\nType Safety - F# types map to SQLite storage types\n\nSchema Builder\nUse the schema\u0026lt;\u0027T\u0026gt; { } computation expression to define schemas:\nopen FractalDb.Schema\n\ntype User = { Name: string; Email: string; Age: int; Active: bool }\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text              // Basic field\n    unique \u0026quot;email\u0026quot; SqliteType.Text            // Unique indexed field\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer          // Indexed field\n    timestamps                                 // Enable CreatedAt/UpdatedAt\n    validate (fun user -\u0026gt;\n        if user.Age \u0026lt; 0 then Error \u0026quot;Age must be positive\u0026quot;\n        elif not (user.Email.Contains(\u0026quot;@\u0026quot;)) then Error \u0026quot;Invalid email\u0026quot;\n        else Ok user\n    )\n}\n\nSchema Operations\nBasic Field\nDefine a field that will be extracted from the JSON document:\nlet schema = schema\u0026lt;MyType\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    field \u0026quot;count\u0026quot; SqliteType.Integer\n    field \u0026quot;price\u0026quot; SqliteType.Real\n    field \u0026quot;active\u0026quot; SqliteType.Boolean\n}\n\nIndexed Field\nCreate an index for fast queries on this field:\nlet schema = schema\u0026lt;User\u0026gt; {\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer      // Fast queries on age\n    indexed \u0026quot;status\u0026quot; SqliteType.Text      // Fast queries on status\n}\n\nIndexed fields provide 28x faster queries compared to non-indexed fields.\nUnique Field\nEnforce uniqueness and create an index:\nlet schema = schema\u0026lt;User\u0026gt; {\n    unique \u0026quot;email\u0026quot; SqliteType.Text        // Must be unique, fast lookups\n    unique \u0026quot;username\u0026quot; SqliteType.Text     // Must be unique, fast lookups\n}\n\nAttempting to insert duplicates returns FractalError.Duplicate.\nComposite Index\nCreate multi-field indexes for queries that filter on multiple fields together:\nlet postSchema = schema\u0026lt;Post\u0026gt; {\n    field \u0026quot;authorId\u0026quot; SqliteType.Text\n    field \u0026quot;status\u0026quot; SqliteType.Text\n    field \u0026quot;publishedAt\u0026quot; SqliteType.Integer\n    compoundIndex \u0026quot;idx_author_status\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;status\u0026quot;]\n    compoundIndex \u0026quot;idx_author_date\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;publishedAt\u0026quot;]\n}\n\nComposite indexes work for queries using the leftmost prefix of fields.\nTimestamps\nEnable automatic timestamp tracking:\nlet schema = schema\u0026lt;MyType\u0026gt; {\n    timestamps    // Adds CreatedAt and UpdatedAt fields\n}\n\nDocuments automatically get:\n- CreatedAt: int64 - Unix timestamp (milliseconds) when created\n- UpdatedAt: int64 - Unix timestamp (milliseconds) when last modified\nValidation\nAdd custom validation that runs before insert/update:\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    unique \u0026quot;email\u0026quot; SqliteType.Text\n    validate (fun user -\u0026gt;\n        if String.IsNullOrWhiteSpace user.Name then\n            Error \u0026quot;Name is required\u0026quot;\n        elif user.Age \u0026lt; 0 then\n            Error \u0026quot;Age must be positive\u0026quot;\n        elif user.Age \u0026gt; 150 then\n            Error \u0026quot;Age must be realistic\u0026quot;\n        elif not (user.Email.Contains(\u0026quot;@\u0026quot;)) then\n            Error \u0026quot;Invalid email format\u0026quot;\n        else\n            Ok user\n    )\n}\n\nValidation errors are returned as FractalError.Validation.\nSQLite Types\n\n\n\nType\nF# Types\nDescription\n\n\n\n\nSqliteType.Text\nstring\nStrings, serialized JSON\n\n\nSqliteType.Integer\nint, int64\n64-bit integers, timestamps\n\n\nSqliteType.Real\nfloat, decimal\nFloating-point numbers\n\n\nSqliteType.Boolean\nbool\nStored as INTEGER (0/1)\n\n\nSqliteType.Blob\nbyte[]\nBinary data\n\n\n\n\nNested Field Indexes\nIndex fields inside nested objects by specifying the JSON path:\ntype Address = { City: string; Country: string; ZipCode: string }\ntype User = { Name: string; Address: Address }\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    indexed \u0026quot;address.city\u0026quot; SqliteType.Text      // Nested field\n    indexed \u0026quot;address.country\u0026quot; SqliteType.Text   // Nested field\n    timestamps\n}\n\nQuery using dot notation:\nlet nycUsers = query {\n    for user in users do\n    where (user.Address.City = \u0026quot;New York\u0026quot;)\n}\n\nHandling Errors\nValidation Errors\ntask {\n    let! result = users |\u0026gt; Collection.insertOne { Name = \u0026quot;\u0026quot;; Email = \u0026quot;invalid\u0026quot;; Age = -5 }\n\n    match result with\n    | Ok doc -\u0026gt; printfn \u0026quot;Created: %s\u0026quot; doc.Id\n    | Error (FractalError.Validation (field, msg)) -\u0026gt;\n        printfn \u0026quot;Validation failed: %s\u0026quot; msg\n    | Error err -\u0026gt;\n        printfn \u0026quot;Error: %s\u0026quot; err.Message\n}\n\nDuplicate Errors\ntask {\n    let! result = users |\u0026gt; Collection.insertOne { Email = \u0026quot;existing@example.com\u0026quot;; ... }\n\n    match result with\n    | Error (FractalError.Duplicate (field, value)) -\u0026gt;\n        printfn \u0026quot;Duplicate %s: %s\u0026quot; field value\n    | _ -\u0026gt; ()\n}\n\nSchema Examples\nUser with Email Uniqueness\ntype User = { Name: string; Email: string; Role: string; Age: int }\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    unique \u0026quot;email\u0026quot; SqliteType.Text\n    indexed \u0026quot;role\u0026quot; SqliteType.Text\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer\n    timestamps\n    validate (fun u -\u0026gt;\n        if String.IsNullOrWhiteSpace u.Email then Error \u0026quot;Email required\u0026quot;\n        elif not (u.Email.Contains(\u0026quot;@\u0026quot;)) then Error \u0026quot;Invalid email\u0026quot;\n        else Ok u\n    )\n}\n\nBlog Post with Composite Index\ntype Post = { Title: string; AuthorId: string; PublishedAt: int64; Status: string }\n\nlet postSchema = schema\u0026lt;Post\u0026gt; {\n    field \u0026quot;title\u0026quot; SqliteType.Text\n    field \u0026quot;authorId\u0026quot; SqliteType.Text\n    indexed \u0026quot;status\u0026quot; SqliteType.Text\n    field \u0026quot;publishedAt\u0026quot; SqliteType.Integer\n    compoundIndex \u0026quot;idx_author_status\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;status\u0026quot;]\n    compoundIndex \u0026quot;idx_author_date\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;publishedAt\u0026quot;]\n    timestamps\n}\n\nE-commerce Product\ntype Product = { Name: string; Sku: string; Price: float; Category: string; InStock: bool }\n\nlet productSchema = schema\u0026lt;Product\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    unique \u0026quot;sku\u0026quot; SqliteType.Text\n    indexed \u0026quot;category\u0026quot; SqliteType.Text\n    indexed \u0026quot;price\u0026quot; SqliteType.Real\n    indexed \u0026quot;inStock\u0026quot; SqliteType.Boolean\n    timestamps\n    validate (fun p -\u0026gt;\n        if p.Price \u0026lt; 0.0 then Error \u0026quot;Price cannot be negative\u0026quot;\n        elif String.IsNullOrWhiteSpace p.Sku then Error \u0026quot;SKU required\u0026quot;\n        else Ok p\n    )\n}\n\nNested Address Index\ntype Location = { City: string; Country: string }\ntype Profile = { Bio: string; Location: Location }\n\nlet profileSchema = schema\u0026lt;Profile\u0026gt; {\n    field \u0026quot;bio\u0026quot; SqliteType.Text\n    indexed \u0026quot;location.city\u0026quot; SqliteType.Text\n    indexed \u0026quot;location.country\u0026quot; SqliteType.Text\n    timestamps\n}\n\nMinimal Schema\nFor simple use cases without indexes or validation:\nlet simpleSchema = schema\u0026lt;MyType\u0026gt; {\n    timestamps    // Just enable timestamps\n}\n\nSchema Operation Reference\n\n\n\nOperation\nSyntax\nDescription\n\n\n\n\nBasic field\nfield \u0022name\u0022 SqliteType.Text\nExtract field from JSON\n\n\nIndexed field\nindexed \u0022name\u0022 SqliteType.Text\nField with index\n\n\nUnique field\nunique \u0022name\u0022 SqliteType.Text\nUnique indexed field\n\n\nComposite index\ncompoundIndex \u0022idx\u0022 [\u0022f1\u0022; \u0022f2\u0022]\nMulti-field index\n\n\nTimestamps\ntimestamps\nEnable auto timestamps\n\n\nValidation\nvalidate (fun x -\u0026gt; Result)\nCustom validation\n\n\n\n\n",
		"headings": [
			"Schemas",
			"Why Schemas Matter",
			"Schema Builder",
			"Schema Operations",
			"Basic Field",
			"Indexed Field",
			"Unique Field",
			"Composite Index",
			"Timestamps",
			"Validation",
			"SQLite Types",
			"Nested Field Indexes",
			"Handling Errors",
			"Validation Errors",
			"Duplicate Errors",
			"Schema Examples",
			"User with Email Uniqueness",
			"Blog Post with Composite Index",
			"E-commerce Product",
			"Nested Address Index",
			"Minimal Schema",
			"Schema Operation Reference"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/indexes.html",
		"title": "Indexes",
		"content": "\nIndexes\nIndexes are critical for query performance. A well-indexed field can be queried 28x faster than a non-indexed field.\nWhy Indexes Matter\nWithout indexes, queries perform full table scans - reading every document to find matches. Indexes create fast lookup structures that dramatically improve query speed.\nPerformance Impact\nBenchmark results from a collection of 1,000 documents:\n\n\n\nQuery Type\nMean Time\nThroughput\nSpeedup\n\n\n\n\nIndexed field\n13.8 us\n72,000 queries/sec\n28x faster\n\n\nNon-indexed field\n391 us\n2,500 queries/sec\nBaseline\n\n\n\n\nWhen to Use Indexes\nAdd indexes when:\n\nField is used in query filters (where clauses)\nField is used for sorting\nField needs uniqueness constraint\nQuery performance is important\n\nDon\u0027t index when:\n\nField is rarely queried\nCollection is very small (\u0026lt; 100 docs)\nField values are not selective (e.g., boolean with 99% true)\nWrite performance is more critical than read performance\n\nSingle Field Indexes\nUse the indexed operation in your schema:\nopen FractalDb.Schema\n\ntype User = { Name: string; Email: string; Age: int }\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    indexed \u0026quot;email\u0026quot; SqliteType.Text       // Index for fast email queries\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer      // Index for fast age queries\n    timestamps\n}\n\nUnique Indexes\nUse unique to create an index that also enforces uniqueness:\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    unique \u0026quot;email\u0026quot; SqliteType.Text        // Unique \u002B indexed\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer      // Just indexed\n    timestamps\n}\n\nUnique indexes are also used for fast lookups:\n// Fast lookup using unique index\nlet emailQuery = query {\n    for user in users do\n    where (user.Email = \u0026quot;alice@example.com\u0026quot;)\n}\nlet! user = users |\u0026gt; Collection.findOne emailQuery\n\nAttempting to insert duplicates returns an error:\nlet! result = users |\u0026gt; Collection.insertOne { Email = \u0026quot;existing@example.com\u0026quot;; ... }\n\nmatch result with\n| Error (FractalError.Duplicate (field, value)) -\u0026gt;\n    printfn \u0026quot;Email already exists: %s\u0026quot; value\n| _ -\u0026gt; ()\n\nComposite Indexes\nCreate multi-field indexes for queries that filter on multiple fields together:\ntype Post = { AuthorId: string; Status: string; PublishedAt: int64 }\n\nlet postSchema = schema\u0026lt;Post\u0026gt; {\n    field \u0026quot;authorId\u0026quot; SqliteType.Text\n    field \u0026quot;status\u0026quot; SqliteType.Text\n    field \u0026quot;publishedAt\u0026quot; SqliteType.Integer\n    compoundIndex \u0026quot;idx_author_status_date\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;status\u0026quot;; \u0026quot;publishedAt\u0026quot;]\n    timestamps\n}\n\nComposite Index Usage\nComposite indexes work for queries using leftmost prefix of fields:\n// Uses idx_author_status_date (matches leftmost field)\nlet byAuthor = query {\n    for post in posts do\n    where (post.AuthorId = \u0026quot;user123\u0026quot;)\n}\n\n// Uses idx_author_status_date (matches first two fields)\nlet byAuthorStatus = query {\n    for post in posts do\n    where (post.AuthorId = \u0026quot;user123\u0026quot;)\n    where (post.Status = \u0026quot;published\u0026quot;)\n}\n\n// Uses idx_author_status_date (matches all three fields)\nlet byAuthorStatusDate = query {\n    for post in posts do\n    where (post.AuthorId = \u0026quot;user123\u0026quot;)\n    where (post.Status = \u0026quot;published\u0026quot;)\n    where (post.PublishedAt \u0026gt; timestamp)\n}\n\n// Does NOT use idx_author_status_date (skips authorId)\nlet byStatusOnly = query {\n    for post in posts do\n    where (post.Status = \u0026quot;published\u0026quot;)\n}\n\nNested Field Indexes\nIndex fields inside nested objects using dot notation:\ntype Address = { City: string; Country: string; ZipCode: string }\ntype User = { Name: string; Address: Address }\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    indexed \u0026quot;address.city\u0026quot; SqliteType.Text      // Index nested field\n    indexed \u0026quot;address.country\u0026quot; SqliteType.Text   // Index nested field\n    timestamps\n}\n\nQuery using the nested path:\n// Query by indexed nested field\nlet nycUsers = query {\n    for user in users do\n    where (user.Address.City = \u0026quot;New York\u0026quot;)\n}\n\nHow Indexes Work\nFractalDb uses SQLite\u0027s generated columns for indexing:\n\nGenerated Column: For each indexed field, a virtual column is created\nJSON Extraction: The column extracts the value from the JSON document\nIndex Creation: A B-tree index is created on the generated column\n\nExample SQL generated:\n-- Generated column\nALTER TABLE users ADD COLUMN _email TEXT\n    GENERATED ALWAYS AS (json_extract(body, \u0027$.email\u0027)) VIRTUAL;\n\n-- Index on generated column\nCREATE UNIQUE INDEX idx_users_email ON users(_email);\n\nThis approach is efficient because:\n- Generated columns are computed once when data is written\n- Indexes use SQLite\u0027s optimized B-tree structures\n- Queries use the index without re-parsing JSON\nIndex Best Practices\n1. Index Fields Used in Filters\n// If you frequently query by status, index it\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    indexed \u0026quot;status\u0026quot; SqliteType.Text\n}\n\nlet activeUsers = query {\n    for user in users do\n    where (user.Status = \u0026quot;active\u0026quot;)\n}\n\n2. Consider Query Patterns\nCreate composite indexes matching your common query patterns:\n// Common query: posts by author, filtered by status\nlet authorPosts = query {\n    for post in posts do\n    where (post.AuthorId = authorId)\n    where (post.Status = \u0026quot;published\u0026quot;)\n}\n\n// Composite index to match\nlet postSchema = schema\u0026lt;Post\u0026gt; {\n    field \u0026quot;authorId\u0026quot; SqliteType.Text\n    field \u0026quot;status\u0026quot; SqliteType.Text\n    compoundIndex \u0026quot;idx_author_status\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;status\u0026quot;]\n}\n\n3. Don\u0027t Over-Index\nEach index:\n- Increases storage space\n- Slows down inserts and updates\n- Must be maintained on every write\nOnly index fields that are frequently queried.\n4. Use Unique for Lookups\nIf you frequently look up by a unique identifier:\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    unique \u0026quot;email\u0026quot; SqliteType.Text\n    unique \u0026quot;username\u0026quot; SqliteType.Text\n}\n\n5. Order Matters in Composite Indexes\nPut the most selective field first:\n// Good: authorId is more selective than status\ncompoundIndex \u0026quot;idx\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;status\u0026quot;]\n\n// Less optimal: status has fewer distinct values\ncompoundIndex \u0026quot;idx\u0026quot; [\u0026quot;status\u0026quot;; \u0026quot;authorId\u0026quot;]\n\nChecking Index Usage\nUse SQLite\u0027s EXPLAIN to verify index usage:\nEXPLAIN QUERY PLAN\nSELECT * FROM users WHERE _email = \u0027test@example.com\u0027;\n\nOutput should show USING INDEX idx_users_email for indexed queries.\nSchema Examples\nUser with Multiple Indexes\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    unique \u0026quot;email\u0026quot; SqliteType.Text        // Unique lookups\n    indexed \u0026quot;role\u0026quot; SqliteType.Text        // Filter by role\n    indexed \u0026quot;createdAt\u0026quot; SqliteType.Integer // Sort by date\n    timestamps\n}\n\nPosts with Composite Index\nlet postSchema = schema\u0026lt;Post\u0026gt; {\n    field \u0026quot;authorId\u0026quot; SqliteType.Text\n    indexed \u0026quot;status\u0026quot; SqliteType.Text\n    field \u0026quot;publishedAt\u0026quot; SqliteType.Integer\n    compoundIndex \u0026quot;idx_author_published\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;publishedAt\u0026quot;]\n    timestamps\n}\n\nProducts with Category Index\nlet productSchema = schema\u0026lt;Product\u0026gt; {\n    unique \u0026quot;sku\u0026quot; SqliteType.Text\n    indexed \u0026quot;category\u0026quot; SqliteType.Text\n    indexed \u0026quot;price\u0026quot; SqliteType.Real\n    compoundIndex \u0026quot;idx_category_price\u0026quot; [\u0026quot;category\u0026quot;; \u0026quot;price\u0026quot;]\n    timestamps\n}\n\n",
		"headings": [
			"Indexes",
			"Why Indexes Matter",
			"Performance Impact",
			"When to Use Indexes",
			"Single Field Indexes",
			"Unique Indexes",
			"Composite Indexes",
			"Composite Index Usage",
			"Nested Field Indexes",
			"How Indexes Work",
			"Index Best Practices",
			"1. Index Fields Used in Filters",
			"2. Consider Query Patterns",
			"3. Don\u0027t Over-Index",
			"4. Use Unique for Lookups",
			"5. Order Matters in Composite Indexes",
			"Checking Index Usage",
			"Schema Examples",
			"User with Multiple Indexes",
			"Posts with Composite Index",
			"Products with Category Index"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/examples.html",
		"title": "Examples",
		"content": "\nFractalDb Examples\nThis page contains F# examples demonstrating FractalDb features.\nBasic Setup\nopen FractalDb\nopen FractalDb.Operators\nopen FractalDb.Options\n\ntype User = {\n    Name: string\n    Email: string\n    Age: int\n}\n\ntype Post = {\n    Title: string\n    Content: string\n    AuthorId: string\n    Tags: string list\n}\n\nCreating a Database\nOpen a file-based or in-memory database:\n// File-based database\nuse db = FractalDb.Open(\u0026quot;example.db\u0026quot;, DbOptions.defaults)\n\n// Or in-memory for testing\n// use db = FractalDb.InMemory()\n\nDefining Schemas\nCreate schemas with indexed fields and validation:\nlet userSchema =\n    schema {\n        field \u0026quot;name\u0026quot; SqliteType.Text (fun u -\u0026gt; u.Name) [ Indexed ]\n        field \u0026quot;email\u0026quot; SqliteType.Text (fun u -\u0026gt; u.Email) [ Indexed; Unique ]\n        field \u0026quot;age\u0026quot; SqliteType.Integer (fun u -\u0026gt; int64 u.Age) [ Indexed ]\n        \n        validate (fun user -\u0026gt;\n            if user.Age \u0026lt; 13 then Error \u0026quot;Must be 13\u002B\u0026quot;\n            elif not (user.Email.Contains(\u0026quot;@\u0026quot;)) then Error \u0026quot;Invalid email\u0026quot;\n            else Ok user\n        )\n    }\n\nlet postSchema =\n    schema {\n        field \u0026quot;authorId\u0026quot; SqliteType.Text (fun p -\u0026gt; p.AuthorId) [ Indexed ]\n        field \u0026quot;title\u0026quot; SqliteType.Text (fun p -\u0026gt; p.Title) [ Indexed ]\n        \n        // Composite index for common queries\n        index \u0026quot;idx_author_title\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;title\u0026quot;]\n        \n        timestamps true\n    }\n\nGetting Collections\nlet users = db.Collection\u0026lt;User\u0026gt;(\u0026quot;users\u0026quot;, userSchema)\nlet posts = db.Collection\u0026lt;Post\u0026gt;(\u0026quot;posts\u0026quot;, postSchema)\n\nInsert Operations\nInsert single and multiple documents:\n// Insert one user\nlet! aliceResult = users.InsertOne({\n    Name = \u0026quot;Alice\u0026quot;\n    Email = \u0026quot;alice@example.com\u0026quot;\n    Age = 30\n})\n\nmatch aliceResult with\n| Ok alice -\u0026gt;\n    printfn \u0026quot;Inserted user: %s (ID: %s)\u0026quot; alice.Data.Name alice.Id\n| Error err -\u0026gt;\n    printfn \u0026quot;Insert failed: %s\u0026quot; err.Message\n\n// Insert many users\nlet! manyResult = users.InsertMany([\n    { Name = \u0026quot;Bob\u0026quot;; Email = \u0026quot;bob@example.com\u0026quot;; Age = 25 }\n    { Name = \u0026quot;Charlie\u0026quot;; Email = \u0026quot;charlie@example.com\u0026quot;; Age = 35 }\n])\n\nmatch manyResult with\n| Ok docs -\u0026gt;\n    printfn \u0026quot;Inserted %d users\u0026quot; docs.Length\n| Error err -\u0026gt;\n    printfn \u0026quot;Batch insert failed: %s\u0026quot; err.Message\n\nQuery Operations\nFind documents using various operators:\n// Find by equality\nlet! activeUsers = users.Find(Query.eq \u0026quot;status\u0026quot; \u0026quot;active\u0026quot;)\n\n// Find with comparison operators\nlet! adults = users.Find(Query.gte \u0026quot;age\u0026quot; 18L)\n\n// Find with string operations\nlet! gmailUsers = users.Find(Query.endsWith \u0026quot;email\u0026quot; \u0026quot;@gmail.com\u0026quot;)\n\n// Complex query with multiple conditions\nlet! results =\n    Query.empty\n    |\u0026gt; Query.gte_ \u0026quot;age\u0026quot; 18L\n    |\u0026gt; Query.endsWith_ \u0026quot;email\u0026quot; \u0026quot;@example.com\u0026quot;\n    |\u0026gt; users.Find\n\nQuery Options\nUse options for sorting, pagination, and projection:\n// Sort and limit\nlet! topUsers =\n    options {\n        sortBy \u0026quot;age\u0026quot; Descending\n        limit 10\n    }\n    |\u0026gt; users.Find Query.empty\n\n// Pagination\nlet! page2 =\n    options {\n        skip 20\n        limit 10\n        sortBy \u0026quot;createdAt\u0026quot; Descending\n    }\n    |\u0026gt; users.Find Query.empty\n\n// Field projection\nlet! names =\n    options {\n        project [\u0026quot;_id\u0026quot;; \u0026quot;name\u0026quot;; \u0026quot;email\u0026quot;]\n    }\n    |\u0026gt; users.Find Query.empty\n\nUpdate Operations\nUpdate documents by ID or query:\nmatch aliceResult with\n| Ok alice -\u0026gt;\n    // Update by ID\n    let! updateResult = users.UpdateById(alice.Id, {| age = 31 |})\n    \n    match updateResult with\n    | Ok (Some updated) -\u0026gt;\n        printfn \u0026quot;Updated: %s is now %d years old\u0026quot; \n            updated.Data.Name updated.Data.Age\n    | Ok None -\u0026gt;\n        printfn \u0026quot;User not found\u0026quot;\n    | Error err -\u0026gt;\n        printfn \u0026quot;Update failed: %s\u0026quot; err.Message\n| _ -\u0026gt; ()\n\n// Update many\nlet! manyUpdated =\n    users.UpdateMany(\n        Query.eq \u0026quot;status\u0026quot; \u0026quot;pending\u0026quot;,\n        {| status = \u0026quot;active\u0026quot; |}\n    )\n\nDelete Operations\nDelete documents by ID or query:\n// Delete by ID\nlet! deleteResult = users.DeleteById(\u0026quot;some-id\u0026quot;)\n\n// Delete many\nlet! deletedCount =\n    users.DeleteMany(Query.eq \u0026quot;status\u0026quot; \u0026quot;inactive\u0026quot;)\n\nmatch deletedCount with\n| Ok count -\u0026gt;\n    printfn \u0026quot;Deleted %d users\u0026quot; count\n| Error err -\u0026gt;\n    printfn \u0026quot;Delete failed: %s\u0026quot; err.Message\n\nTransactions\nGroup multiple operations in ACID transactions:\nlet! txResult =\n    db.Transact(fun tx -\u0026gt; task {\n        // Insert user\n        let! user = users.InsertOne({\n            Name = \u0026quot;David\u0026quot;\n            Email = \u0026quot;david@example.com\u0026quot;\n            Age = 28\n        }, tx)\n        \n        // Insert posts by that user\n        let! post1 = posts.InsertOne({\n            Title = \u0026quot;Hello World\u0026quot;\n            Content = \u0026quot;My first post\u0026quot;\n            AuthorId = user.Id\n            Tags = [\u0026quot;intro\u0026quot;; \u0026quot;hello\u0026quot;]\n        }, tx)\n        \n        let! post2 = posts.InsertOne({\n            Title = \u0026quot;FractalDb Tutorial\u0026quot;\n            Content = \u0026quot;How to use FractalDb\u0026quot;\n            AuthorId = user.Id\n            Tags = [\u0026quot;tutorial\u0026quot;; \u0026quot;fsharp\u0026quot;]\n        }, tx)\n        \n        return (user, post1, post2)\n    })\n\nmatch txResult with\n| Ok (user, post1, post2) -\u0026gt;\n    printfn \u0026quot;Transaction succeeded!\u0026quot;\n    printfn \u0026quot;User: %s\u0026quot; user.Id\n    printfn \u0026quot;Posts: %s, %s\u0026quot; post1.Id post2.Id\n| Error err -\u0026gt;\n    printfn \u0026quot;Transaction rolled back: %s\u0026quot; err.Message\n\nError Handling\nHandle different error types:\nlet! insertResult = users.InsertOne({\n    Name = \u0026quot;Eve\u0026quot;\n    Email = \u0026quot;eve@example.com\u0026quot;\n    Age = 20\n})\n\nmatch insertResult with\n| Ok doc -\u0026gt;\n    printfn \u0026quot;Success: %s\u0026quot; doc.Id\n| Error (ConstraintViolation msg) -\u0026gt;\n    printfn \u0026quot;Unique constraint failed: %s\u0026quot; msg\n| Error (ValidationError msg) -\u0026gt;\n    printfn \u0026quot;Validation failed: %s\u0026quot; msg\n| Error (SerializationError (msg, _)) -\u0026gt;\n    printfn \u0026quot;Serialization error: %s\u0026quot; msg\n| Error err -\u0026gt;\n    printfn \u0026quot;Other error: %s\u0026quot; err.Message\n\nCount Documents\nlet! totalUsers = users.Count(Query.empty)\nlet! adultCount = users.Count(Query.gte \u0026quot;age\u0026quot; 18L)\n\nmatch (totalUsers, adultCount) with\n| (Ok total, Ok adults) -\u0026gt;\n    printfn \u0026quot;Total users: %d, Adults: %d\u0026quot; total adults\n| _ -\u0026gt;\n    printfn \u0026quot;Count failed\u0026quot;\n\nFind One and Find by ID\n// Find one matching document\nlet! firstAdult = users.FindOne(Query.gte \u0026quot;age\u0026quot; 18L)\n\nmatch firstAdult with\n| Ok (Some doc) -\u0026gt;\n    printfn \u0026quot;First adult: %s (%d years old)\u0026quot; doc.Data.Name doc.Data.Age\n| Ok None -\u0026gt;\n    printfn \u0026quot;No adults found\u0026quot;\n| Error err -\u0026gt;\n    printfn \u0026quot;Query failed: %s\u0026quot; err.Message\n\n// Find by ID\nlet! userById = users.FindById(\u0026quot;some-id\u0026quot;)\n\nComplete Example: Blog System\nHere\u0027s a complete example of a simple blog system:\ntype BlogUser = {\n    Username: string\n    Email: string\n    Bio: string option\n}\n\ntype BlogPost = {\n    Title: string\n    Content: string\n    AuthorId: string\n    Published: bool\n    PublishedAt: int64 option\n}\n\nlet blogUserSchema =\n    schema {\n        field \u0026quot;username\u0026quot; SqliteType.Text (fun u -\u0026gt; u.Username) [ Indexed; Unique ]\n        field \u0026quot;email\u0026quot; SqliteType.Text (fun u -\u0026gt; u.Email) [ Indexed; Unique ]\n        timestamps true\n        validate (fun u -\u0026gt;\n            if u.Username.Length \u0026lt; 3 then Error \u0026quot;Username too short\u0026quot;\n            elif not (u.Email.Contains(\u0026quot;@\u0026quot;)) then Error \u0026quot;Invalid email\u0026quot;\n            else Ok u\n        )\n    }\n\nlet blogPostSchema =\n    schema {\n        field \u0026quot;authorId\u0026quot; SqliteType.Text (fun p -\u0026gt; p.AuthorId) [ Indexed ]\n        field \u0026quot;published\u0026quot; SqliteType.Boolean (fun p -\u0026gt; p.Published) [ Indexed ]\n        field \u0026quot;publishedAt\u0026quot; SqliteType.Integer (fun p -\u0026gt; \n            p.PublishedAt |\u0026gt; Option.defaultValue 0L\n        ) []\n        index \u0026quot;idx_author_published\u0026quot; [\u0026quot;authorId\u0026quot;; \u0026quot;publishedAt\u0026quot;]\n        timestamps true\n    }\n\nlet blogUsers = db.Collection\u0026lt;BlogUser\u0026gt;(\u0026quot;blog_users\u0026quot;, blogUserSchema)\nlet blogPosts = db.Collection\u0026lt;BlogPost\u0026gt;(\u0026quot;blog_posts\u0026quot;, blogPostSchema)\n\n// Create user and posts in a transaction\nlet! blogResult =\n    db.Transact(fun tx -\u0026gt; task {\n        // Create user\n        let! author = blogUsers.InsertOne({\n            Username = \u0026quot;techblogger\u0026quot;\n            Email = \u0026quot;blog@example.com\u0026quot;\n            Bio = Some \u0026quot;I love F# and functional programming\u0026quot;\n        }, tx)\n        \n        // Create published post\n        let! post = blogPosts.InsertOne({\n            Title = \u0026quot;Getting Started with FractalDb\u0026quot;\n            Content = \u0026quot;FractalDb is an embedded document database...\u0026quot;\n            AuthorId = author.Id\n            Published = true\n            PublishedAt = Some (System.DateTimeOffset.UtcNow.ToUnixTimeMilliseconds())\n        }, tx)\n        \n        return (author, post)\n    })\n\n// Query published posts by author\nmatch blogResult with\n| Ok (author, _) -\u0026gt;\n    let! authorPosts =\n        Query.empty\n        |\u0026gt; Query.eq_ \u0026quot;authorId\u0026quot; author.Id\n        |\u0026gt; Query.eq_ \u0026quot;published\u0026quot; true\n        |\u0026gt; blogPosts.Find\n    \n    match authorPosts with\n    | Ok posts -\u0026gt;\n        printfn \u0026quot;Author %s has %d published posts\u0026quot; author.Data.Username posts.Length\n    | _ -\u0026gt; ()\n| _ -\u0026gt; ()\n\nCleanup\nClose the database when done (or use use for automatic disposal):\ndb.Close()\n\nNext Steps\n\n*Getting Started* - Learn the basics\n*Query Expressions* - Master querying\n*Transactions* - Work with transactions\n*Schemas* - Define schemas\n*Indexes* - Optimize performance\n\n",
		"headings": [
			"FractalDb Examples",
			"Basic Setup",
			"Creating a Database",
			"Defining Schemas",
			"Getting Collections",
			"Insert Operations",
			"Query Operations",
			"Query Options",
			"Update Operations",
			"Delete Operations",
			"Transactions",
			"Error Handling",
			"Count Documents",
			"Find One and Find by ID",
			"Complete Example: Blog System",
			"Cleanup",
			"Next Steps"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/getting-started.html",
		"title": "Getting Started",
		"content": "\nGetting Started with FractalDb\nThis guide walks you through installing FractalDb, creating your first database, and performing basic CRUD operations.\nInstallation\nRequirements\n\n*.NET 9.0 or higher*\nF# 9.0\u002B\n\nBuild from Source\ngit clone https://github.com/takinprofit/FractalDb.git\ncd FractalDb\ndotnet build FractalDb.sln\n\nCreating a Database\nFractalDb supports both file-based and in-memory databases.\nFile-Based Database\nopen FractalDb\n\n// Open or create a database file\nlet db = FractalDb.Open(\u0026quot;myapp.db\u0026quot;)\n\n// Use the database...\n\n// Close when done\ndb.Close()\n\nIn-Memory Database\nPerfect for testing or temporary data:\n// Create an in-memory database\nlet db = FractalDb.InMemory()\n\n// All data is lost when db is disposed\n\nDefining Document Types\nDefine your document types as F# records:\ntype User = {\n    Name: string\n    Email: string\n    Age: int\n    Active: bool\n}\n\ntype Post = {\n    Title: string\n    Content: string\n    AuthorId: string\n    Tags: list\u0026lt;string\u0026gt;\n}\n\nDefining Schemas\nUse the schema\u0026lt;\u0027T\u0026gt; { } computation expression to define which fields should be indexed:\nopen FractalDb.Schema\n\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text              // Basic field\n    unique \u0026quot;email\u0026quot; SqliteType.Text            // Unique indexed field\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer          // Indexed field\n    timestamps                                 // Enable CreatedAt/UpdatedAt\n    validate (fun user -\u0026gt;\n        if user.Age \u0026lt; 0 then Error \u0026quot;Age must be positive\u0026quot;\n        else Ok user\n    )\n}\n\nSchema Operations\n\n\n\nOperation\nDescription\n\n\n\n\nfield \u0022name\u0022 SqliteType.Text\nBasic field\n\n\nindexed \u0022name\u0022 SqliteType.Text\nField with index (fast queries)\n\n\nunique \u0022name\u0022 SqliteType.Text\nUnique indexed field\n\n\ncompoundIndex \u0022idx\u0022 [\u0022f1\u0022; \u0022f2\u0022]\nComposite index\n\n\ntimestamps\nEnable auto timestamps\n\n\nvalidate (fun x -\u0026gt; ...)\nValidation function\n\n\n\n\nSQLite Types\n\nSqliteType.Text - Strings\nSqliteType.Integer - 64-bit integers\nSqliteType.Real - Floating-point\nSqliteType.Boolean - Boolean (stored as 0/1)\nSqliteType.Blob - Binary data\n\nGetting a Collection\nlet users = db.Collection\u0026lt;User\u0026gt;(\u0026quot;users\u0026quot;, userSchema)\n\nBasic CRUD Operations\nInsert Documents\nopen FractalDb.Collection\n\n// Insert a single document\ntask {\n    let! result = users |\u0026gt; Collection.insertOne {\n        Name = \u0026quot;Alice\u0026quot;\n        Email = \u0026quot;alice@example.com\u0026quot;\n        Age = 30\n        Active = true\n    }\n\n    match result with\n    | Ok doc -\u0026gt;\n        printfn \u0026quot;Created document with ID: %s\u0026quot; doc.Id\n        printfn \u0026quot;Created at: %d\u0026quot; doc.CreatedAt\n    | Error err -\u0026gt;\n        printfn \u0026quot;Error: %s\u0026quot; err.Message\n}\n\n// Insert multiple documents\ntask {\n    let! result = users |\u0026gt; Collection.insertMany [\n        { Name = \u0026quot;Bob\u0026quot;; Email = \u0026quot;bob@example.com\u0026quot;; Age = 25; Active = true }\n        { Name = \u0026quot;Charlie\u0026quot;; Email = \u0026quot;charlie@example.com\u0026quot;; Age = 35; Active = false }\n    ]\n\n    match result with\n    | Ok batch -\u0026gt;\n        printfn \u0026quot;Inserted %d documents\u0026quot; batch.InsertedCount\n    | Error err -\u0026gt;\n        printfn \u0026quot;Error: %s\u0026quot; err.Message\n}\n\nQuery Documents with Query Expressions\nUse the query { } computation expression for type-safe, LINQ-style queries:\nopen FractalDb.QueryExpr\n\n// Find adults\ntask {\n    let adultQuery = query {\n        for user in users do\n        where (user.Age \u0026gt;= 18)\n    }\n    let! adults = users |\u0026gt; Collection.executeQuery adultQuery\n    printfn \u0026quot;Found %d adults\u0026quot; (List.length adults)\n}\n\n// Find active adults sorted by name\ntask {\n    let q = query {\n        for user in users do\n        where (user.Age \u0026gt;= 18)\n        where (user.Active = true)\n        sortBy user.Name\n        take 10\n    }\n    let! results = users |\u0026gt; Collection.executeQuery q\n    for user in results do\n        printfn \u0026quot;%s (%d)\u0026quot; user.Data.Name user.Data.Age\n}\n\nFind by ID\ntask {\n    let! doc = users |\u0026gt; Collection.findById \u0026quot;some-id\u0026quot;\n    match doc with\n    | Some user -\u0026gt; printfn \u0026quot;Found: %s\u0026quot; user.Data.Name\n    | None -\u0026gt; printfn \u0026quot;Not found\u0026quot;\n}\n\nUpdate Documents\n// Update by ID with a function\ntask {\n    let! updated = users |\u0026gt; Collection.updateById \u0026quot;some-id\u0026quot; (fun user -\u0026gt;\n        { user with Age = user.Age \u002B 1 }\n    )\n\n    match updated with\n    | Some doc -\u0026gt; printfn \u0026quot;Updated: %s is now %d\u0026quot; doc.Data.Name doc.Data.Age\n    | None -\u0026gt; printfn \u0026quot;Document not found\u0026quot;\n}\n\n// Replace entire document\ntask {\n    let! replaced = users |\u0026gt; Collection.replaceById \u0026quot;some-id\u0026quot; {\n        Name = \u0026quot;Alice Smith\u0026quot;\n        Email = \u0026quot;alice.smith@example.com\u0026quot;\n        Age = 31\n        Active = true\n    }\n\n    match replaced with\n    | Some doc -\u0026gt; printfn \u0026quot;Replaced: %s\u0026quot; doc.Data.Name\n    | None -\u0026gt; printfn \u0026quot;Document not found\u0026quot;\n}\n\nDelete Documents\n// Delete by ID\ntask {\n    let! count = users |\u0026gt; Collection.deleteById \u0026quot;some-id\u0026quot;\n    printfn \u0026quot;Deleted %d document(s)\u0026quot; count\n}\n\n// Delete matching query\ntask {\n    let inactiveQuery = query {\n        for user in users do\n        where (user.Active = false)\n    }\n    let! count = users |\u0026gt; Collection.deleteMany inactiveQuery\n    printfn \u0026quot;Deleted %d inactive users\u0026quot; count\n}\n\nError Handling\nAll operations return Result\u0026lt;\u0027T, FractalError\u0026gt; or Task\u0026lt;Result\u0026lt;\u0027T, FractalError\u0026gt;\u0026gt;:\ntask {\n    let! result = users |\u0026gt; Collection.insertOne newUser\n\n    match result with\n    | Ok doc -\u0026gt;\n        // Success - use the document\n        printfn \u0026quot;Success: %s\u0026quot; doc.Id\n    | Error err -\u0026gt;\n        // Handle specific error types\n        match err with\n        | FractalError.Validation (field, msg) -\u0026gt;\n            printfn \u0026quot;Validation error on %A: %s\u0026quot; field msg\n        | FractalError.Duplicate (field, value) -\u0026gt;\n            printfn \u0026quot;Duplicate %s: %s\u0026quot; field value\n        | FractalError.NotFound id -\u0026gt;\n            printfn \u0026quot;Not found: %s\u0026quot; id\n        | _ -\u0026gt;\n            printfn \u0026quot;Error: %s\u0026quot; err.Message\n}\n\nNext Steps\n\nQuery Expressions - Learn the full query syntax\nTransactions - Group operations in ACID transactions\nSchemas - Advanced schema configuration\nIndexes - Optimize query performance\n\n",
		"headings": [
			"Getting Started with FractalDb",
			"Installation",
			"Requirements",
			"Build from Source",
			"Creating a Database",
			"File-Based Database",
			"In-Memory Database",
			"Defining Document Types",
			"Defining Schemas",
			"Schema Operations",
			"SQLite Types",
			"Getting a Collection",
			"Basic CRUD Operations",
			"Insert Documents",
			"Query Documents with Query Expressions",
			"Find by ID",
			"Update Documents",
			"Delete Documents",
			"Error Handling",
			"Next Steps"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/index.html",
		"title": "FractalDb",
		"content": "\nFractalDb\nA lightweight F# document database built on SQLite with LINQ-style query expressions.\nWhat is FractalDb?\nFractalDb is an embedded document database that runs in-process with your .NET application. It combines the simplicity of document storage with the reliability of SQLite, providing type-safe query expressions and declarative schema definitions.\nKey Features\n\nQuery Expressions - LINQ-style query { for x in collection do where ... } syntax\nSchema Builder - Declarative schema\u0026lt;\u0027T\u0026gt; { field ... indexed ... } expressions\nHigh Performance - 71,400\u002B docs/sec batch inserts, 72,000\u002B queries/sec indexed\nACID Transactions - Full transaction support with db.Transact { } builder\nIndexed Queries - Single and composite indexes (28x speedup)\nValidation - Custom validation rules in schema definitions\nAutomatic Timestamps - Built-in CreatedAt/UpdatedAt tracking\nType Safety - F# type system ensures compile-time correctness\n\nQuick Example\nopen FractalDb\nopen FractalDb.Schema\nopen FractalDb.Collection\nopen FractalDb.QueryExpr\n\n// Document type\ntype User = { Name: string; Email: string; Age: int; Active: bool }\n\n// Schema with computation expression\nlet userSchema = schema\u0026lt;User\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    unique \u0026quot;email\u0026quot; SqliteType.Text\n    indexed \u0026quot;age\u0026quot; SqliteType.Integer\n    timestamps\n    validate (fun u -\u0026gt; if u.Age \u0026lt; 0 then Error \u0026quot;Invalid age\u0026quot; else Ok u)\n}\n\n// Database and collection\nlet db = FractalDb.Open(\u0026quot;app.db\u0026quot;)\nlet users = db.Collection\u0026lt;User\u0026gt;(\u0026quot;users\u0026quot;, userSchema)\n\n// Insert\ntask {\n    let! result = users |\u0026gt; Collection.insertOne {\n        Name = \u0026quot;Alice\u0026quot;; Email = \u0026quot;alice@example.com\u0026quot;; Age = 30; Active = true\n    }\n    match result with\n    | Ok doc -\u0026gt; printfn \u0026quot;Created: %s\u0026quot; doc.Id\n    | Error err -\u0026gt; printfn \u0026quot;Error: %s\u0026quot; err.Message\n}\n\n// Query with LINQ-style expression\ntask {\n    let adultQuery = query {\n        for user in users do\n        where (user.Age \u0026gt;= 18)\n        where (user.Active = true)\n        sortBy user.Name\n        take 10\n    }\n    let! results = users |\u0026gt; Collection.executeQuery adultQuery\n    for user in results do\n        printfn \u0026quot;%s\u0026quot; user.Data.Name\n}\n\n// Transactions\ntask {\n    let! result = db.Transact {\n        let! u1 = users |\u0026gt; Collection.insertOne { Name = \u0026quot;Bob\u0026quot;; Email = \u0026quot;bob@test.com\u0026quot;; Age = 25; Active = true }\n        let! u2 = users |\u0026gt; Collection.insertOne { Name = \u0026quot;Carol\u0026quot;; Email = \u0026quot;carol@test.com\u0026quot;; Age = 35; Active = true }\n        return (u1.Id, u2.Id)\n    }\n    match result with\n    | Ok _ -\u0026gt; printfn \u0026quot;Committed\u0026quot;\n    | Error err -\u0026gt; printfn \u0026quot;Rolled back\u0026quot;\n}\n\ndb.Close()\n\nPerformance\n\n\n\nOperation\nThroughput\n\n\n\n\nSingle insert\n~2,700 ops/sec\n\n\nBatch insert (1000 docs)\n~71,400 docs/sec\n\n\nIndexed query\n~72,000 queries/sec\n\n\nNon-indexed query\n~2,500 queries/sec\n\n\n\n\nDocumentation\n\nGetting Started - Installation and first steps\nQuery Expressions - LINQ-style query syntax\nSchemas - Schema builder and validation\nTransactions - ACID transaction patterns\nIndexes - Optimizing query performance\nAPI Reference - Full API documentation\n\n",
		"headings": [
			"FractalDb",
			"What is FractalDb?",
			"Key Features",
			"Quick Example",
			"Performance",
			"Documentation"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/transactions.html",
		"title": "Transactions",
		"content": "\nTransactions\nFractalDb provides full ACID transaction support using the db.Transact { } computation expression. Group multiple operations that either all succeed or all fail together.\nWhy Use Transactions?\nTransactions are essential for:\n\nAtomicity - Multiple operations succeed or fail as a unit\nConsistency - Database stays in a valid state\nData Integrity - Related changes are applied together\nPerformance - Batch operations are faster in transactions (4x speedup)\n\nBasic Transaction Usage\nUsing db.Transact\nThe db.Transact computation expression provides a clean way to execute operations in a transaction:\nopen FractalDb\nopen FractalDb.Collection\n\nlet! result =\n    db.Transact {\n        // All operations share the same transaction\n        let! user = users |\u0026gt; Collection.insertOne { Name = \u0026quot;Alice\u0026quot;; Email = \u0026quot;alice@test.com\u0026quot;; Age = 30; Active = true }\n        let! post = posts |\u0026gt; Collection.insertOne { Title = \u0026quot;Hello\u0026quot;; AuthorId = user.Id }\n\n        // Return both documents\n        return (user, post)\n    }\n\nmatch result with\n| Ok (user, post) -\u0026gt;\n    printfn \u0026quot;Transaction committed: user %s, post %s\u0026quot; user.Id post.Id\n| Error err -\u0026gt;\n    printfn \u0026quot;Transaction rolled back: %s\u0026quot; err.Message\n\nKey Points:\n- Returns Task\u0026lt;Result\u0026lt;\u0027T, FractalError\u0026gt;\u0026gt;\n- Automatically commits on success (Ok)\n- Automatically rolls back on error (Error) or exception\nTransaction Behavior\nAutomatic Commit\nWhen all operations succeed (return Ok), the transaction commits:\nlet! result =\n    db.Transact {\n        let! doc1 = collection |\u0026gt; Collection.insertOne data1\n        let! doc2 = collection |\u0026gt; Collection.insertOne data2\n        return (doc1.Id, doc2.Id)  // Both committed\n    }\n\nAutomatic Rollback on Error\nWhen any operation returns Error, the transaction rolls back:\nlet! result =\n    db.Transact {\n        let! doc1 = collection |\u0026gt; Collection.insertOne validData\n        // If this fails (e.g., duplicate key), doc1 is also rolled back\n        let! doc2 = collection |\u0026gt; Collection.insertOne duplicateData\n        return (doc1, doc2)\n    }\n\nmatch result with\n| Ok _ -\u0026gt; printfn \u0026quot;Success\u0026quot;\n| Error err -\u0026gt; printfn \u0026quot;Rolled back: %s\u0026quot; err.Message\n\nExplicit Error Return\nYou can explicitly return an error to trigger rollback:\nlet! result =\n    db.Transact {\n        let! doc = collection |\u0026gt; Collection.insertOne data\n\n        // Validation after insert\n        if doc.Data.Amount \u0026gt; 10000 then\n            return! Task.FromResult(Error(FractalError.Validation(None, \u0026quot;Amount too large\u0026quot;)))\n        else\n            return doc\n    }\n\nTransaction Patterns\nTransfer Between Accounts\nlet transfer fromId toId amount =\n    db.Transact {\n        // Get both accounts\n        let! fromAccount = accounts |\u0026gt; Collection.findById fromId\n        let! toAccount = accounts |\u0026gt; Collection.findById toId\n\n        match fromAccount, toAccount with\n        | Some from, Some to\u0026#39; when from.Data.Balance \u0026gt;= amount -\u0026gt;\n            // Update both accounts\n            let! _ = accounts |\u0026gt; Collection.updateById fromId (fun a -\u0026gt;\n                { a with Balance = a.Balance - amount })\n            let! _ = accounts |\u0026gt; Collection.updateById toId (fun a -\u0026gt;\n                { a with Balance = a.Balance \u002B amount })\n            return Ok amount\n        | Some from, Some _ -\u0026gt;\n            return! Task.FromResult(Error(FractalError.Validation(None, \u0026quot;Insufficient funds\u0026quot;)))\n        | _ -\u0026gt;\n            return! Task.FromResult(Error(FractalError.NotFound \u0026quot;Account not found\u0026quot;))\n    }\n\nBatch Insert with Validation\nlet insertWithValidation items =\n    db.Transact {\n        let! doc1 = collection |\u0026gt; Collection.insertOne items.[0]\n        let! doc2 = collection |\u0026gt; Collection.insertOne items.[1]\n        let! doc3 = collection |\u0026gt; Collection.insertOne items.[2]\n\n        // All three inserted or none\n        return [doc1; doc2; doc3]\n    }\n\nMulti-Collection Operations\nlet createUserWithProfile userData profileData =\n    db.Transact {\n        let! user = users |\u0026gt; Collection.insertOne userData\n        let! profile = profiles |\u0026gt; Collection.insertOne { profileData with UserId = user.Id }\n        return (user, profile)\n    }\n\nError Handling in Transactions\nTry-With for Exceptions\nlet! result =\n    db.Transact {\n        try\n            let! doc = collection |\u0026gt; Collection.insertOne data\n            return doc\n        with ex -\u0026gt;\n            return! Task.FromResult(Error(FractalError.Database ex.Message))\n    }\n\nHandling Specific Errors\nlet! result =\n    db.Transact {\n        let! insertResult = collection |\u0026gt; Collection.insertOne data\n\n        // The computation expression handles Result automatically\n        // If insertResult is Error, transaction rolls back\n        return insertResult\n    }\n\nmatch result with\n| Ok doc -\u0026gt; printfn \u0026quot;Created: %s\u0026quot; doc.Id\n| Error (FractalError.Duplicate (field, value)) -\u0026gt;\n    printfn \u0026quot;Duplicate %s: %s\u0026quot; field value\n| Error (FractalError.Validation (field, msg)) -\u0026gt;\n    printfn \u0026quot;Validation error: %s\u0026quot; msg\n| Error err -\u0026gt;\n    printfn \u0026quot;Error: %s\u0026quot; err.Message\n\nPerformance Considerations\nTransactions Improve Batch Performance\nTransactions reduce overhead for multiple operations:\n\n\n\nScenario\nTime\nSpeedup\n\n\n\n\n5 inserts without transaction\n1.76 ms\nBaseline\n\n\n5 inserts in transaction\n442 us\n4x faster\n\n\n\n\nBest Practices\n\nKeep transactions short - Long transactions hold locks\nBatch related operations - Group writes that should be atomic\nUse insertMany for bulk inserts - Already uses internal transaction\nDon\u0027t nest transactions - insertMany has its own transaction, don\u0027t wrap it\n\nAvoid Nested Transactions\nSQLite doesn\u0027t support nested transactions. Don\u0027t wrap insertMany in a transaction:\n// WRONG - causes nested transaction error\nlet! result =\n    db.Transact {\n        let! batch = collection |\u0026gt; Collection.insertMany items  // Already transactional!\n        return batch\n    }\n\n// CORRECT - use insertMany directly\nlet! result = collection |\u0026gt; Collection.insertMany items\n\nTransaction vs No Transaction\nUse transactions when:\n- Multiple operations must succeed or fail together\n- You need atomicity across collections\n- You\u0027re doing read-modify-write operations\nDon\u0027t use transactions when:\n- Single operation (already atomic)\n- Using insertMany (has internal transaction)\n- Read-only operations\nComplete Example\nopen FractalDb\nopen FractalDb.Schema\nopen FractalDb.Collection\n\ntype Account = { Name: string; Balance: decimal }\ntype Transfer = { FromId: string; ToId: string; Amount: decimal; Timestamp: int64 }\n\nlet accountSchema = schema\u0026lt;Account\u0026gt; {\n    field \u0026quot;name\u0026quot; SqliteType.Text\n    indexed \u0026quot;balance\u0026quot; SqliteType.Real\n    timestamps\n}\n\nlet transferSchema = schema\u0026lt;Transfer\u0026gt; {\n    indexed \u0026quot;fromId\u0026quot; SqliteType.Text\n    indexed \u0026quot;toId\u0026quot; SqliteType.Text\n    timestamps\n}\n\nlet db = FractalDb.Open(\u0026quot;bank.db\u0026quot;)\nlet accounts = db.Collection\u0026lt;Account\u0026gt;(\u0026quot;accounts\u0026quot;, accountSchema)\nlet transfers = db.Collection\u0026lt;Transfer\u0026gt;(\u0026quot;transfers\u0026quot;, transferSchema)\n\nlet performTransfer fromId toId amount =\n    db.Transact {\n        let! fromAccount = accounts |\u0026gt; Collection.findById fromId\n        let! toAccount = accounts |\u0026gt; Collection.findById toId\n\n        match fromAccount, toAccount with\n        | Some from, Some to\u0026#39; when from.Data.Balance \u0026gt;= amount -\u0026gt;\n            // Debit source\n            let! _ = accounts |\u0026gt; Collection.updateById fromId (fun a -\u0026gt;\n                { a with Balance = a.Balance - amount })\n            // Credit destination\n            let! _ = accounts |\u0026gt; Collection.updateById toId (fun a -\u0026gt;\n                { a with Balance = a.Balance \u002B amount })\n            // Record transfer\n            let! transfer = transfers |\u0026gt; Collection.insertOne {\n                FromId = fromId\n                ToId = toId\n                Amount = amount\n                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()\n            }\n            return transfer\n        | Some _, Some _ -\u0026gt;\n            return! Task.FromResult(Error(FractalError.Validation(None, \u0026quot;Insufficient funds\u0026quot;)))\n        | _ -\u0026gt;\n            return! Task.FromResult(Error(FractalError.NotFound \u0026quot;Account not found\u0026quot;))\n    }\n\n// Usage\ntask {\n    let! result = performTransfer \u0026quot;acc-001\u0026quot; \u0026quot;acc-002\u0026quot; 100m\n    match result with\n    | Ok transfer -\u0026gt; printfn \u0026quot;Transfer complete: %s\u0026quot; transfer.Id\n    | Error err -\u0026gt; printfn \u0026quot;Transfer failed: %s\u0026quot; err.Message\n}\n\n",
		"headings": [
			"Transactions",
			"Why Use Transactions?",
			"Basic Transaction Usage",
			"Using db.Transact",
			"Transaction Behavior",
			"Automatic Commit",
			"Automatic Rollback on Error",
			"Explicit Error Return",
			"Transaction Patterns",
			"Transfer Between Accounts",
			"Batch Insert with Validation",
			"Multi-Collection Operations",
			"Error Handling in Transactions",
			"Try-With for Exceptions",
			"Handling Specific Errors",
			"Performance Considerations",
			"Transactions Improve Batch Performance",
			"Best Practices",
			"Avoid Nested Transactions",
			"Transaction vs No Transaction",
			"Complete Example"
		],
		"type": "content"
	},
	{
		"uri": "https://takinprofit.github.io/FractalDb/query-expressions.html",
		"title": "Query Expressions",
		"content": "\nQuery Expressions\nFractalDb provides LINQ-style query expressions using the query { } computation expression. This is the primary API for querying documents with type-safe, composable syntax.\nBasic Queries\nQuery Structure\nEvery query starts with for ... in ... do:\nopen FractalDb.QueryExpr\nopen FractalDb.Collection\n\nlet myQuery = query {\n    for doc in collection do\n    where (doc.Field = value)\n}\n\nlet! results = collection |\u0026gt; Collection.executeQuery myQuery\n\nSimple Filter\n// Find all active users\nlet activeQuery = query {\n    for user in users do\n    where (user.Active = true)\n}\n\nMultiple Filters (AND)\nMultiple where clauses are combined with AND:\n// Find active adults\nlet activeAdults = query {\n    for user in users do\n    where (user.Age \u0026gt;= 18)\n    where (user.Active = true)\n}\n\nComparison Operators\nUse standard F# comparison operators in where clauses:\n// Equal\nwhere (user.Status = \u0026quot;active\u0026quot;)\n\n// Not equal\nwhere (user.Status \u0026lt;\u0026gt; \u0026quot;deleted\u0026quot;)\n\n// Greater than\nwhere (user.Age \u0026gt; 18)\n\n// Greater than or equal\nwhere (user.Age \u0026gt;= 18)\n\n// Less than\nwhere (user.Age \u0026lt; 65)\n\n// Less than or equal\nwhere (user.Age \u0026lt;= 65)\n\nComparison Examples\n// Users between 18 and 65\nlet workingAge = query {\n    for user in users do\n    where (user.Age \u0026gt;= 18)\n    where (user.Age \u0026lt; 65)\n}\n\n// High-value orders\nlet highValue = query {\n    for order in orders do\n    where (order.Total \u0026gt; 1000.0)\n}\n\nLogical Operators\nAND Conditions\nUse \u0026amp;\u0026amp; or multiple where clauses:\n// Using \u0026amp;\u0026amp;\nlet admins = query {\n    for user in users do\n    where (user.Role = \u0026quot;admin\u0026quot; \u0026amp;\u0026amp; user.Active = true)\n}\n\n// Using multiple where (equivalent)\nlet admins = query {\n    for user in users do\n    where (user.Role = \u0026quot;admin\u0026quot;)\n    where (user.Active = true)\n}\n\nOR Conditions\nUse || for OR logic:\n// Admin or moderator\nlet privileged = query {\n    for user in users do\n    where (user.Role = \u0026quot;admin\u0026quot; || user.Role = \u0026quot;moderator\u0026quot;)\n}\n\n// Multiple conditions\nlet featured = query {\n    for post in posts do\n    where (post.Featured = true || post.Views \u0026gt; 10000)\n}\n\nNOT Conditions\nUse not for negation:\n// Not deleted\nlet active = query {\n    for user in users do\n    where (not (user.Status = \u0026quot;deleted\u0026quot;))\n}\n\nComplex Logic\nCombine operators for complex conditions:\n// Active admins or any superuser\nlet privileged = query {\n    for user in users do\n    where ((user.Role = \u0026quot;admin\u0026quot; \u0026amp;\u0026amp; user.Active = true) || user.Superuser = true)\n}\n\nString Operations\nUse string methods in where clauses:\n// Contains substring\nlet gmail = query {\n    for user in users do\n    where (user.Email.Contains(\u0026quot;@gmail.com\u0026quot;))\n}\n\n// Starts with prefix\nlet aNames = query {\n    for user in users do\n    where (user.Name.StartsWith(\u0026quot;A\u0026quot;))\n}\n\n// Ends with suffix\nlet dotCom = query {\n    for user in users do\n    where (user.Email.EndsWith(\u0026quot;.com\u0026quot;))\n}\n\nString Examples\n// Search by name prefix\nlet searchByPrefix prefix = query {\n    for user in users do\n    where (user.Name.StartsWith(prefix))\n    sortBy user.Name\n}\n\n// Find users with company emails\nlet companyUsers = query {\n    for user in users do\n    where (user.Email.EndsWith(\u0026quot;@mycompany.com\u0026quot;))\n}\n\nSorting\nAscending Sort\nlet alphabetical = query {\n    for user in users do\n    sortBy user.Name\n}\n\nDescending Sort\nlet newest = query {\n    for post in posts do\n    sortByDescending post.CreatedAt\n}\n\nCombined with Filters\n// Active users sorted by name\nlet activeByName = query {\n    for user in users do\n    where (user.Active = true)\n    sortBy user.Name\n}\n\n// Top posts by views\nlet topPosts = query {\n    for post in posts do\n    where (post.Published = true)\n    sortByDescending post.Views\n    take 10\n}\n\nPagination\nLimit Results\n// Get first 10\nlet first10 = query {\n    for user in users do\n    take 10\n}\n\nSkip Results\n// Skip first 20\nlet afterFirst20 = query {\n    for user in users do\n    skip 20\n}\n\nCombined Pagination\n// Page 3 (10 items per page)\nlet page3 = query {\n    for user in users do\n    sortBy user.Name\n    skip 20\n    take 10\n}\n\nNested Fields\nQuery nested object properties using dot notation:\ntype Address = { City: string; Country: string; ZipCode: string }\ntype User = { Name: string; Address: Address }\n\n// Query nested field\nlet nycUsers = query {\n    for user in users do\n    where (user.Address.City = \u0026quot;New York\u0026quot;)\n}\n\n// Multiple nested conditions\nlet usUsers = query {\n    for user in users do\n    where (user.Address.Country = \u0026quot;USA\u0026quot;)\n    where (user.Address.City = \u0026quot;New York\u0026quot;)\n}\n\nProjections\nUse select to project specific fields:\n// Select single field\nlet names = query {\n    for user in users do\n    select user.Name\n}\n\n// Select nested field\nlet cities = query {\n    for user in users do\n    select user.Address.City\n}\n\nExecuting Queries\nGet All Matching Documents\ntask {\n    let myQuery = query {\n        for user in users do\n        where (user.Active = true)\n        sortBy user.Name\n    }\n    let! results = users |\u0026gt; Collection.executeQuery myQuery\n    for doc in results do\n        printfn \u0026quot;%s\u0026quot; doc.Data.Name\n}\n\nCount Matching Documents\ntask {\n    let activeQuery = query {\n        for user in users do\n        where (user.Active = true)\n    }\n    let! count = users |\u0026gt; Collection.count activeQuery\n    printfn \u0026quot;Active users: %d\u0026quot; count\n}\n\nFind One Document\ntask {\n    let emailQuery = query {\n        for user in users do\n        where (user.Email = \u0026quot;alice@example.com\u0026quot;)\n    }\n    let! user = users |\u0026gt; Collection.findOne emailQuery\n    match user with\n    | Some doc -\u0026gt; printfn \u0026quot;Found: %s\u0026quot; doc.Data.Name\n    | None -\u0026gt; printfn \u0026quot;Not found\u0026quot;\n}\n\nComplete Examples\nUser Search\nlet searchUsers namePrefix minAge maxAge = query {\n    for user in users do\n    where (user.Name.StartsWith(namePrefix))\n    where (user.Age \u0026gt;= minAge)\n    where (user.Age \u0026lt;= maxAge)\n    where (user.Active = true)\n    sortBy user.Name\n    take 50\n}\n\nRecent Posts\nlet recentPublished authorId = query {\n    for post in posts do\n    where (post.AuthorId = authorId)\n    where (post.Published = true)\n    sortByDescending post.CreatedAt\n    take 10\n}\n\nE-commerce Orders\nlet highValuePending = query {\n    for order in orders do\n    where (order.Total \u0026gt; 100.0)\n    where (order.Status = \u0026quot;pending\u0026quot;)\n    sortByDescending order.Total\n}\n\nUsers by Location\nlet usersInCity city = query {\n    for user in users do\n    where (user.Address.City = city)\n    where (user.Active = true)\n    sortBy user.Name\n}\n\nQuery Expression Reference\n\n\n\nOperation\nSyntax\nDescription\n\n\n\n\nStart\nfor x in collection do\nBegin query\n\n\nFilter\nwhere (predicate)\nFilter documents\n\n\nSort Ascending\nsortBy x.Field\nSort ascending\n\n\nSort Descending\nsortByDescending x.Field\nSort descending\n\n\nLimit\ntake n\nLimit results\n\n\nSkip\nskip n\nSkip results\n\n\nProject\nselect x.Field\nSelect field\n\n\n\n\nPredicate Reference\n\n\n\nOperation\nSyntax\n\n\n\n\nEqual\nx.Field = value\n\n\nNot Equal\nx.Field \u0026lt;\u0026gt; value\n\n\nGreater Than\nx.Field \u0026gt; value\n\n\nGreater or Equal\nx.Field \u0026gt;= value\n\n\nLess Than\nx.Field \u0026lt; value\n\n\nLess or Equal\nx.Field \u0026lt;= value\n\n\nAND\npred1 \u0026amp;\u0026amp; pred2\n\n\nOR\npred1 \\|\\| pred2\n\n\nNOT\nnot pred\n\n\nContains\nx.Field.Contains(\u0022text\u0022)\n\n\nStarts With\nx.Field.StartsWith(\u0022prefix\u0022)\n\n\nEnds With\nx.Field.EndsWith(\u0022suffix\u0022)\n\n\n\n\n",
		"headings": [
			"Query Expressions",
			"Basic Queries",
			"Query Structure",
			"Simple Filter",
			"Multiple Filters (AND)",
			"Comparison Operators",
			"Comparison Examples",
			"Logical Operators",
			"AND Conditions",
			"OR Conditions",
			"NOT Conditions",
			"Complex Logic",
			"String Operations",
			"String Examples",
			"Sorting",
			"Ascending Sort",
			"Descending Sort",
			"Combined with Filters",
			"Pagination",
			"Limit Results",
			"Skip Results",
			"Combined Pagination",
			"Nested Fields",
			"Projections",
			"Executing Queries",
			"Get All Matching Documents",
			"Count Matching Documents",
			"Find One Document",
			"Complete Examples",
			"User Search",
			"Recent Posts",
			"E-commerce Orders",
			"Users by Location",
			"Query Expression Reference",
			"Predicate Reference"
		],
		"type": "content"
	}
]
